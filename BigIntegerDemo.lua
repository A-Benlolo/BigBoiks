local BigInteger=require "BigInteger"

local function main()
  --Working Data
  local p=BigInteger:new("8675309", '-')
  local q=BigInteger:new("42069", '+')
  local exponent1=BigInteger:new("4", '+')
  local exponent2=BigInteger:new("1234567890987654321", '+')
  local hexNum=BigInteger:new("123456789abcdef0", '+', 16)
  local binNum1=BigInteger:new("1010", '+', 2)
  local binNum2=BigInteger:new("111", '+', 2)
  
  --Expected Results
  local expectedSum=BigInteger:new("8633240", '-')
  local expectedDiff=BigInteger:new("8717378", '-')
  local expectedProd=BigInteger:new("364961574321", '-')
  local expectedQuot, expectedRema=BigInteger:new("206", '-'), BigInteger:new("9095", '+')
  local expectedModu=BigInteger:new("32974", '+')
  local expectedPowr=BigInteger:new("5664216050642480268792921361", '+')
  local expectedModuPow=BigInteger:new("1", '+')
  local expectedToDec=BigInteger:new("1311768467463790320", '+')
  local expectedAbsP=BigInteger:new("8675309", '+')
  local expectedAbsQ=BigInteger:new("42069", '+')
  local expectedMax=BigInteger:new("42069", '+')
  local expectedMin=BigInteger:new("8675309", '-')
  local expectedNegQ=BigInteger:new("42069", '-')
  local expectedNegP=BigInteger:new("8675309", '+')
  local expectedToHex="123456789ABCDEF0"
  local expectedPPrime=true
  local expectedQPrime=false
  local expectedBinAnd=BigInteger:new("10", '+', 2)
  local expectedBinOr=BigInteger:new("1111", '+', 2)
  local expectedBinXor=BigInteger:new("1101", '+', 2)
  
  io.write(",----------------,\n")
  io.write("|    ADDITION    |\n")
  io.write("`----------------`\n")
  local sum=p:add(q)
  io.write("  ", p:toString(), "\n")
  io.write("+    ", q:toString(), "\n")
  io.write("==========\n")
  io.write("  ", sum:toString(), "\n\n")
  
  io.write(",----------------,\n")
  io.write("|  SUBTRACTION   |\n")
  io.write("`----------------`\n")
  local diff=p:subtract(q)
  io.write("  ", p:toString(), "\n")
  io.write("-    ", q:toString(), "\n")
  io.write("==========\n")
  io.write("  ", diff:toString(), "\n\n")
  
  io.write(",----------------,\n")
  io.write("| MULTIPLICATION |\n")
  io.write("`----------------`\n")
  local prod=p:multiply(q)
  io.write("       ", p:toString(), "\n")
  io.write("*         ", q:toString(), "\n")
  io.write("===============\n")
  io.write("  ", prod:toString(), "\n\n")
  
  io.write(",----------------,\n")
  io.write("|    DIVISION    |\n")
  io.write("`----------------`\n")
  local quot, rema=p:divide(q)
  io.write("    ", p:toString(), "\n")
  io.write("/      ", q:toString(), "\n")
  io.write("============\n")
  io.write(" ", quot:toString(), " R ", rema:toString(), "\n\n")
  
  
  io.write(",----------------,\n")
  io.write("|     MODULUS    |\n")
  io.write("`----------------`\n")
  local modu=p:mod(q)
  io.write("    ", p:toString(), "\n")
  io.write("%      ", q:toString(), "\n")
  io.write("============\n")
  io.write("       ", modu:toString(), "\n\n")
  
  io.write(",----------------,\n")
  io.write("|      POWER     |\n")
  io.write("`----------------`\n")
  local powr=p:pow(exponent1)
  io.write(p:toString(), "^", exponent1:toString(), " = ", powr:toString(), "\n\n")

  io.write(",----------------,\n")
  io.write("|     MOD-POW    |\n")
  io.write("`----------------`\n")
  local moduPow=p:modPow(exponent2, q)
  io.write(p:toString(), "^", exponent2:toString(), " ≡ ", moduPow:toString(), " (mod ", q:toString(), ")\n\n")
  
  io.write(",----------------,\n")
  io.write("|     RANDOM     |\n")
  io.write("`----------------`\n")
  local rand=q:random()
  io.write("Random 0<r<", q:toString(), " = ", rand:toString(), "\n\n")
  
  io.write(",----------------,\n")
  io.write("|   HEX <-> DEC  |\n")
  io.write("`----------------`\n")
  io.write("Hexidecimal string converted to a BigInteger = ", hexNum:toString(), "\n")
  io.write("BigInteger value printed in base 16 = ", hexNum:toString(16), "\n\n")
  
  io.write(",----------------,\n")
  io.write("|    ABS VALUE   |\n")
  io.write("`----------------`\n")
  local absP=p:abs()
  local absQ=q:abs()
  io.write("Absolute value of ", p:toString(), " = ", absP:toString(), "\n")
  io.write("Absolute value of ", q:toString(), " = ", absQ:toString(), "\n\n")

  io.write(",----------------,\n")
  io.write("|     MIN/MAX    |\n")
  io.write("`----------------`\n")
  local max=p:max(q)
  local min=p:min(q)
  io.write("Maximum value between ", p:toString(), " and ", q:toString(), " = ", max:toString(), "\n")
  io.write("Minimum value between ", p:toString(), " and ", q:toString(), " = ", min:toString(), "\n\n")
  
  io.write(",----------------,\n")
  io.write("|    NEGATION    |\n")
  io.write("`----------------`\n")
  local negP=p:negate()
  local negQ=q:negate()
  io.write("Negation of ", p:toString(), " = ", negP:toString(), "\n")
  io.write("Negation of ", q:toString(), " = ", negQ:toString(), "\n\n")
  
  io.write(",----------------,\n")
  io.write("|    EUCLIDEAN   |\n")
  io.write("`----------------`\n")
  local gcd, s, t=absP:Euclidean(absQ)
  io.write(absP:toString(), "*", s:toString(), " + ", absQ:toString(), "*", t:toString(), " = ", absP:multiply(s):add(absQ:multiply(t)):toString(), "\n\n")
  
  io.write(",----------------,\n")
  io.write("|   MULT. INV.   |\n")
  io.write("`----------------`\n")
  local multInv=absQ:inverse(absP)
  io.write(absQ:toString(), "*", multInv:toString(), " ≡ ", multInv:multiply(absQ):mod(absP):toString(), " (mod ", absP:toString(),")\n\n")
  
  io.write(",----------------,\n")
  io.write("|    PRIMALITY   |\n")
  io.write("`----------------`\n")
  local pPrime=absP:isProbablePrime(5)
  local qPrime=absQ:isProbablePrime(5)
  io.write("Is ", absP:toString(), " a prime number? ", (pPrime and "Probably" or "No"), ".\n")
  io.write("Is ", absQ:toString(), " a prime number? ", (qPrime and "Yes" or "No"), ".\n\n")
  
  io.write(",----------------,\n")
  io.write("|    BIT-WISE    |\n")
  io.write("`----------------`\n")
  local binAnd=binNum1:bitwiseAnd(binNum2)
  local binOr=binNum1:bitwiseOr(binNum2)
  local binXor=binNum1:bitwiseXor(binNum2)
  io.write("(", binNum1:toString(2), ")(", binNum2:toString(2), ") = ", binAnd:toString(2), "\n")
  io.write(binNum1:toString(2), " + ", binNum2:toString(2), " = ", binOr:toString(2), "\n")
  io.write(binNum1:toString(2), " (+) ", binNum2:toString(2), " = ", binXor:toString(2), "\n\n")
  
  io.write(",~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,\n")
  io.write("|               Results:               |\n")
  io.write("|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n")
  io.write(string.format("|%-30s : %-5s|\n", "Addition Correct", (sum:equals(expectedSum) and "True" or "False")))
  io.write(string.format("|%-30s : %-5s|\n", "Subtraction Correct", (diff:equals(expectedDiff) and "True" or "False")))
  io.write(string.format("|%-30s : %-5s|\n", "Multiplication Correct", (prod:equals(expectedProd) and "True" or "False")))
  io.write(string.format("|%-30s : %-5s|\n", "Division Correct", (quot:equals(expectedQuot) and rema:equals(expectedRema) and "True" or "False")))
  io.write(string.format("|%-30s : %-5s|\n", "Modulus Correct", (modu:equals(expectedModu) and "True" or "False")))
  io.write(string.format("|%-30s : %-5s|\n", "Exponentiation Correct", (powr:equals(expectedPowr) and "True" or "False")))
  io.write(string.format("|%-30s : %-5s|\n", "Modular-Exponentiation Correct", (moduPow:equals(expectedModuPow) and "True" or "False")))
  io.write(string.format("|%-30s : %-5s|\n", "Random number is in Bounds", (rand:lessThan(q) and rand:greaterThan(BigInteger.ZERO())) and "True" or "False"))
  io.write(string.format("|%-30s : %-5s|\n", "Hex -> Dec Conversion Correct", (hexNum:equals(expectedToDec)) and "True" or "False"))
  io.write(string.format("|%-30s : %-5s|\n", "Dec -> Hex Conversion Correct", hexNum:toString(16)==expectedToHex and "True" or "False"))
  io.write(string.format("|%-30s : %-5s|\n", "Absolute Value Correct", (absP:equals(expectedAbsP) and absQ:equals(expectedAbsQ)) and "True" or "False"))
  io.write(string.format("|%-30s : %-5s|\n", "Maximum Value Correct", (max:equals(expectedMax)) and "True" or "False"))
  io.write(string.format("|%-30s : %-5s|\n", "Minimum Value Correct", (min:equals(expectedMin)) and "True" or "False"))
  io.write(string.format("|%-30s : %-5s|\n", "Negation Correct", (negP:equals(expectedNegP) and negQ:equals(expectedNegQ)) and "True" or "False"))
  io.write(string.format("|%-30s : %-5s|\n", "Euclidean Algorithim Correct", (absP:multiply(s):add(absQ:multiply(t)):equals(gcd)) and "True" or "False"))
  io.write(string.format("|%-30s : %-5s|\n", "Multiplicative Inverse Correct", (multInv:multiply(absQ):mod(absP):equals(BigInteger.ONE())) and "True" or "False"))
  io.write(string.format("|%-30s : %-5s|\n", "Primality Test Correct", (pPrime==expectedPPrime and qPrime==expectedQPrime) and "True" or "False"))
  io.write(string.format("|%-30s : %-5s|\n", "Bitwise Operations Correct", (binAnd:equals(expectedBinAnd) and binOr:equals(expectedBinOr) and binXor:equals(expectedBinXor)) and "True" or "False"))
  io.write("`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`\n")
end

io.write("\n")
main()
io.write("\n")
